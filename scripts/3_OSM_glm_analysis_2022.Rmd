---
title: "OSM report 2022-2023"
author: "Marissa Dyck"
date: "2024-05-08"
output: 
  html_document:
    theme: journal
    toc: yes
    toc_float: yes
---

The first two chunks of this r markdown file after the r setup allow for plot zooming, but it also means that the html file must be opened in a browser to view the document properly. When it knits in RStudio the preview will appear empty but the html when opened in a browser will have all the info and you can click on each plot to Zoom in on it. 

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)

library(tidyverse)
```

```{css zoom-lib-src, echo = FALSE}
script src = "https://ajax.googleapis.com/ajax/libs/jquery/3.4.1/jquery.min.js"
```

```{js zoom-jquery, echo = FALSE}
 $(document).ready(function() {
    $('body').prepend('<div class=\"zoomDiv\"><img src=\"\" class=\"zoomImg\"></div>');
    // onClick function for all plots (img's)
    $('img:not(.zoomImg)').click(function() {
      $('.zoomImg').attr('src', $(this).attr('src')).css({width: '100%'});
      $('.zoomDiv').css({opacity: '1', width: 'auto', border: '1px solid white', borderRadius: '5px', position: 'fixed', top: '50%', left: '50%', marginRight: '-50%', transform: 'translate(-50%, -50%)', boxShadow: '0px 0px 50px #888888', zIndex: '50', overflow: 'auto', maxHeight: '100%'});
    });
    // onClick function for zoomImg
    $('img.zoomImg').click(function() {
      $('.zoomDiv').css({opacity: '0', width: '0%'}); 
    });
  });
```

# Before you begin

## Notes

A few notes about this script.

If you are running this with the 2022-2023 data make sure you download the whole (OSM_2022-2023 GitHub repository)[https://github.com/ACMElabUvic/OSM_2022-2023] from the ACMElabUvic GitHub. This will ensure you have all the files, data, and proper folder structure you will need to run this code and associated analyses.

Also make sure you open RStudio through the R project (OSM_2022-2023.Rproj) this will automatically set your working directory to the correct place (wherever you saved the repository) and ensure you don't have to change the file paths for some of the data.

Lastly, if you are looking to adapt this code for a future year of data, you will want to ensure you have run the 2_ACME_landscape_covariate_exploration_script.Rmd with your data as there is much data formatting, cleaning, and restructuring that has to be done before this code will work. *Helpful note: The files are numbered in the order they are used for this analysis*.

If you have question please email the most recent author, currently   

Marissa A. Dyck   
Postdoctoral research fellow    
University of Victoria    
School of Environmental Studies     
Email: [marissadyck17@gmail.com](marissadyck17@gmail.com)      

(*update/add authors as needed*)

## Install packages

If you don't already have the following packages installed, use the code below to install them.

```{r install packages, eval=FALSE}

install.packages('tidyverse') 
install.packages('ggpubr')
install.packages('corrplot')
install.packages('Hmisc')
install.packages('glmmTMB')
install.packages('MuMIn')
install.packages('TMB', type = 'source')
install.packages('rphylopic')
install.packages('broom')
```

## Load libraries

Then load the packages to your library.

```{r libraries, message=FALSE}

library(tidyverse) # data tidying, visualization, and much more; this will load all tidyverse packages, can see complete list using tidyverse_packages()
library(ggpubr) # make modificaions to plot for publication (arrange plots)
library(PerformanceAnalytics)    #Used to generate a correlation plot
library(Hmisc) # used to generate histograms for all variables in data frame
library(glmmTMB)      #Constructing GLMMs
library(MuMIn) # for model selection
library(rphylopic) # add animal silhouettes to graphs
library(broom) # extracting odds ratios in a tidy format

```

# Summary statistics

## Load detection data

Read in saved and cleaned detection data for the 6 LUs from 2021-2022 and 2022-2023 e.g., the 1_ACME_camera_script_9-2-2024.R.

These are two separate files from the two different fiscal years, so they need to be imported and then merged into one data file for plotting. Since both are stored in the data/processed/ folder we can read them both in as a list with *purrr*.

```{r data}

# detection data
# read in saved and cleaned detection data from the ACME_camera_script_9-2-2024.R 
detections <- file.path('data/processed',
                        
                        c('OSM_ind_det_2021.csv',
                          'OSM_ind_det_2022.csv')) %>% 
  
 map(~.x %>%
        read_csv(.) %>% 
       
       # ensure the array, site, species, and event_id read in as factors
       mutate_if(is.character,
                 as.factor)) %>% 
  
  # give names to each data frame in list
  purrr::set_names('dets_2021',
                   'dets_2022') # R doesn't like when they are just numbers, you can make it work but it's annoying to call the data frame later so I've called them dets_year

str(detections)
```

## Merge data

Now we need to merge these two files to make plotting easier. 

They have the same columns so we could just the base R `rbind()` function, but in case there are differences in the columns in the future, let's use the cleaner `dplyr::bind_rows()` function

```{r}

# Join two years of detection data
detections_merged <- dplyr::bind_rows(detections$dets_2021,
                                      detections$dets_2022)

# check new data
str(detections_merged)
```

## Data checks

Let's check to make sure the data looks good after merging

### Arrays and sites

Let's check that there are the correct number of levels for array and sites, there should be 6 arrays and 233 sites (155 from 2022-2023 and 78 from 2021-2022)

```{r}
str(detections_merged)

# check the levels for array and sites
levels(detections_merged$array)
levels(detections_merged$site)
```
Everything looks good

### NAs

Let's ensure no NAs were introduced where there shouldn't be during the joining process

```{r}
# check for NAs introduced during data merge
summary(detections_merged)
```
THe only NAs are in the timediff column which is what we expect since any of the first observations won't have a timediff.


## Data Formatting

In order to get plots that have the same formatting as last years' report we have to do a bit of data formatting. First we need to make sure we are including the same relevant species (some were ignored for last years' report or grouped together)

Last years report had the following species

* white-tailed deer
* snowshoe hare
* black bear
* coyote
* red squirrel
* fisher
* unknown
* moose
* lynx
* spruce grouse
* red fox
* striped skunk
* ruffed grouse
* owl
* grey wolf
* domestic dog
* cougar
* raven
* other 
* mule deer

And they grouped all humans except for staff as 'Humans'. Let's look at the species we have in the combined years of data and try to format it the same way

```{r det species}

detections_merged %>% 
  
  # group by array and species
  group_by(species) %>% 
  summarise(n = n()) %>% 
  
  # have R print everything
  print(n = nrow(.))
```
>Hmmm there is one instance of an arctic hare, check that this isn't meant to be a snowshoe hare and fix later if needed. 


Now let's create a new data frame (tibble) to work with for the OSM figure summaries specifically

*I personally would lump all the unknown together and all the birds together but for the sake of consistency with last year's figures we will remove the same entries and keep the birds separate, let's create a vector of entries to drop*

```{r det format}
species_drop <- c('Staff',
                  'Unknown deer',
                  'Unknown ungulate',
                  'Unknown canid',
                  'Unknown mustelid',
                  'Other birds',
                  'Arctic hare')

# now we can create the new data frame with some changes consistent w/ choices made for 2021-2022
detections_merged <- detections_merged %>% 
  
  # for summarizing, lets lump all the recreational humans into "Humans"
  mutate(species = recode_factor(species, 
                                 "Snowmobiler" = "Human",
                                 "ATVer" = "Human",
                                 'Hunter' = 'Human')) %>% 
  
  # remove species we don't want to plot
  filter(!species %in% species_drop)

# look at data
str(detections_merged)

```

## Subset data

We will also want to subset the data by landscape unit (LU) and generate a new data frame for each LU to use for plotting

I'm not great at writing loops, so let's see how this shit goes... probably bad but who knows
```{r det subset forloop }

array_frames <- list()

for (i in unique(detections_merged$array)){
  
   #Subset data based on radius
  df <- detections_merged %>%
    filter(array == i)
  
 # list of dataframes
  array_frames <- c(array_frames, list(df))
  
 
}

# inspect one data frame
print(array_frames[[1]]) # this is for LU2
```
... I think this worked


Now let's change names of list items using purrr, couldn't figure out how to name them in the loop, you don't necessarily need to do this because we change the names in the next section, but I like having things named

```{r name array frames}
array_frames <- array_frames %>%

  purrr::set_names('LU02',
                   'LU03',
                   'LU01',
                   'LU13',
                   'LU15',
                   'LU21') 

# inspect each data frame
head(array_frames$LU01)
```


# Detection plots

## Detection data

Now we can apply the same data formatting for each LUs' data frame using purrr.

We want to count the number of independent detections per species per LU to use in the detection plots

```{r det data}

# apply the same formatting to each LU data frame using purrr map
detection_data <- array_frames %>% 
  
  purrr::map(
    ~.x %>% 
      
      # group by species
      group_by(species) %>%
      
      # calculate a column with unique accounts of each species
      mutate(count = n_distinct(event_id)) %>% 
      
      # keep just the columns we need
      select(species, count) %>% 
      
      # keep only unique (distinct) rows so we should be left with one row per species, this helps with plotting later if you don't do it ggplot will try to count and plot each row it's annoying
      distinct()) %>% 
  
  # set names of list objects
  purrr::set_names('Detections LU02',
                   'Detections LU03',
                   'Detections LU01',
                   'Detections LU13',
                   'Detections LU15',
                   'Detections LU21')

```


## Detection plots

Now to graph independent detections for each LU using purrr, this avoids a TON of code repetition needed to plot each one individually

We use `purrr::imap()` instead of `purrr::map()` because imap maintains the variable names in our list (e.g. Detections LU01, Detections LU13, etc.) which we can then use to title each plot.

Within `purrr::imap()` we just paste the code we would use for a single ggplot since all the graphical elements (except the title which we change with the file name [.y]) are the same

```{r det plots}
# create object detection plots which uses the detection_data list (w/ all 4 LUs)
detection_plots <- detection_data %>% 
  
  # use imap instead of map as it allows us to use .y to paste the list element names as the plot titles later
  purrr::imap(
    ~.x %>% 
      
      # now just copy and paste the ggplot code for the detection graphs
      ggplot(.,
             aes(x = reorder(species, count), y = count)) +
      
      # plot as bar graph using geom_col so we don't have to provide a y aesthetic
      geom_col() +
      
      # switch the x and y axis
      coord_flip() +
      
      # add the number of detections at the end of each bar
      geom_text(aes(label = count),
                color = "black",
                size = 3,
                hjust = -0.3,
                vjust = 0.2) +
      
      # label x and y axis with informative titles
      labs(x = 'Species',
           y = 'Number of Independent (30 min) Detections') +
      
      # add title to plot with LU name the .y will take the name of whatever you named each list element in the detection_data list, so make sure this name is what you want on the ggtitle
      ggtitle(.y) +
      
      # set the theme
      theme_classic() +
      theme(plot.title = element_text(hjust = 0.5)))

# view plots, this will print each in it's own window so you have to scroll back in the plot viewer pane to look at each one
detection_plots

```

## Save detection plots

Now we want to save these plots in case we need each individual one (we will combine the detection and naive occ plots into a single figure for each LU later and use those for the OSM report, but we may want these standalone plots later so let's save them while they are here).

We can save all the plots from the purrr iteration above using `purrr::imap`. imap is used instead of map because it allows us to retain the list object names (plot names) to paste as the file name with the .y command.

> IMPORTANT if you are using this code for a future github repo, DO NOT use .tiff as the file extension. This will cause issues when trying to push any changes to the github repo as the files are too large to meet githubs requirements

```{r save det plots, eval=FALSE}

# save plots only use if needed
purrr::imap(
  detection_plots,
  ~ggsave(.x,
             file = paste0("figures/OSM_",
                           .y,
                           '.jpg'), # avoid using .tiff extension in the github repo, those files are too large to push to origin
          dpi = 600,
          width = 11,
          height = 9,
          units = 'in'))

```

# Naive occupancy

## Data

We also need to alter the detection data a bit to use for naive occupancy plots. 

We will use the individual LU detection data like we did before and use `purrr::map()` to apply the dame data formatting to all 4 data frames.

Here we want to calculate the total number of sites in each LU, the number of sites each species was detected at in each LU and then use both those numbers to calculate naive occupancy for each species in each LU

```{r occ data}

# First we need to alter the data frame a bit for these plots, let's create a data frame for each LU (I couldn't figure out how to do this without assigning individual data frames for each UGH)


# apply the same formatting to each data frame using purrr
occupancy_data <- array_frames %>% 
  
  purrr::map(
    ~.x %>% 
      
      # calculate the total number of sites for each LU
      mutate(total_sites = n_distinct(site)) %>% 
      
      # group by species to calculate the number of sites each spp occurred at
      group_by(species) %>% 
  
      # add columns to count the number of sites each spp occurred at and then the naive occupancy
  reframe(count = n_distinct(site),
          naive_occ = count/total_sites,
          ind_det = n_distinct(event_id)) %>% 
  
    # keep just the columns we need
  select(species, naive_occ, ind_det) %>% 
  
    # keep only unique (distinct) rows so we should be left with one row per species, this helps with plotting
  distinct()) %>% 
  
  purrr::set_names('Naive Occupancy LU02',
                   'Naive Occupancy LU03',
                   'Naive Occupancy LU01',
                   'Naive Occupancy LU13',
                   'Naive Occupancy LU15',
                   'Naive Occupancy LU21')
```

## Occupancy plots

Now we can graph naive occupancy for each LU using purrr, and as with the detection plots this saves a massive amount of coding using purrr to run an iteration on the data files and produce four plots at once instead of copying and pasting code for each individually

```{r occ plots}
# create object occupancy_plots which uses the occupancy_data list (w/ all 4 LUs)
occupancy_plots <- occupancy_data %>% 
  
  # use imap instead of map as it allows us to use .y to paste the list element names as the plot titles later
  purrr::imap(
    ~.x %>% 

      # now just copy and paste the ggplot code for the occupancy graphs
      ggplot(.,
             aes(x = fct_reorder(species,
                                 ind_det), # this reorders the species so they match the order of the detection plot which makes it better for viewing when the plots are arranged together in 1 figure for each LU
                 y = naive_occ)) +
      
      # plot as bars using geom_col() which uses stat = 'identity', instead of geom_bar() which will count the rows in each group and plot that instead of naive occ
      geom_col() +
      
      # flip x and y axis 
      coord_flip() +
      
      # add text to end of bars that provides naive occ value
      geom_text(aes(label = round(naive_occ, 2)), 
                size = 3, 
                hjust = -0.3, 
                vjust = 0.2) +
      
      # relabel x and y axis and title
      labs(x = 'Species',
           y = 'Proportion of Sites With At Least One Detection') +
      
      # set plot title using .y (name of list object)
      ggtitle(.y) +
      
      # set. theme elements
      theme_classic()+
      theme(plot.title = element_text(hjust = 0.5)))

# view plots
occupancy_plots
```

## Save occupancy plots

As with the detection plots, we might want these individual plots later for something so we can use `purrr::imap()` to save them to the figures folder

Again avoid using the .tiff extension in github

```{r save occ plots, eval=FALSE}

# save plots 
purrr::imap(
  occupancy_plots,
  ~ggsave(.x,
          file = paste0("figures/OSM_",
                        .y,
                        '.jpg'), # avoid using .tiff extension in the github repo, those files are too large to push to origin
          dpi = 600,
          width = 11,
          height = 9,
          units = 'in'))

```

# Final combined plots for report

The previous year's report had a figure for each LU with the detections plot on the top and the occupancy plot on the bottom so we will recreate these for this year using `ggarrange()`.

Unfortunately I could not figure out how to do this in purrr to reduce coding but luckily it isn't too much repetition


```{r combine plots}

# not sure I know how to do the following section in purrr just yet, but we've saved a ton of coding so far and it doesn't take much to arrange each of these individually

# LU2
LU02_det_occ_plots <- ggarrange(detection_plots$`Detections LU02`, 
                               occupancy_plots$`Naive Occupancy LU02`,
                               labels = c("A", "B"),
                               nrow = 2)

# view plot
LU02_det_occ_plots


# LU3
LU03_det_occ_plots <- ggarrange(detection_plots$`Detections LU03`, 
                               occupancy_plots$`Naive Occupancy LU03`,
                               labels = c("A", "B"),
                               nrow = 2)

# view plot
LU03_det_occ_plots

# LU1

# arrange the plots so each LU has a figure with detections on top and naive occ on bottom
LU01_det_occ_plots <- ggarrange(detection_plots$`Detections LU01`, 
                               occupancy_plots$`Naive Occupancy LU01`,
                               labels = c("A", "B"),
                               nrow = 2)

# view plot
LU01_det_occ_plots

# LU13

# arrange the plots so each LU has a figure with detections on top and naive occ on bottom
LU13_det_occ_plots <- ggarrange(detection_plots$`Detections LU13`, 
                                occupancy_plots$`Naive Occupancy LU13`,
                               labels = c("A", "B"),
                               nrow = 2)

# view plot
LU13_det_occ_plots


# LU15

# arrange the plots so each LU has a figure with detections on top and naive occ on bottom
LU15_det_occ_plots <- ggarrange(detection_plots$`Detections LU15`, 
                                occupancy_plots$`Naive Occupancy LU15`,
                                labels = c("A", "B"),
                                nrow = 2)

# view plot
LU15_det_occ_plots


# LU21

# arrange the plots so each LU has a figure with detections on top and naive occ on bottom
LU21_det_occ_plots <- ggarrange(detection_plots$`Detections LU21`, 
                                occupancy_plots$`Naive Occupancy LU21`,
                                labels = c("A", "B"),
                                nrow = 2)

# view plot
LU21_det_occ_plots

```

We can however, save all the figures again using purrr

```{r save combine plots, eval=FALSE}

# save all figures at once using purrr
final_det_occ_plots <- list(LU02_det_occ_plots,
                            LU03_det_occ_plots,
                            LU01_det_occ_plots,
                            LU13_det_occ_plots,
                            LU15_det_occ_plots,
                            LU21_det_occ_plots) %>% 
  

  purrr::set_names('LU02_det_occ_plots',
                   'LU03_det_occ_plots',
                   'LU01_det_occ_plots',
                   'LU13_det_occ_plots',
                   'LU15_det_occ_plots',
                   'LU21_det_occ_plots') %>% 
  
  purrr::imap(
    ~ggsave(.x,
            file = paste0("figures/OSM_",
                          .y,
                          '.jpg'), # avoid using .tiff extension in the github repo, those files are too large to push to origin
            dpi = 600,
            width = 12,
            height = 15,
            units = 'in'))

```

## Finish with detection data

Before proceeding let's clear the objects currently in our environment since we don't need them for the analysis

```{r clear env}
rm(list = ls(all.names = TRUE))
```

# Analysis prep

Now we can start the analysis prep.

First we need to read in the proportional detection (response metrics) and covariate (explanatory metrics) data files for all 6 LUs (fiscal years 2021-2022 and 2022-2023)


## Response metrics

### Read in data files

We haven't joined the response metrics from 2021-2022 and 2022-2023 in any previous scripts yet, so let's read those in using *purrr* and then join them and take a look at the data to make sure it looks good. 

```{r}
# response metric (proportional detections from the from the ACME_camera_script_9-2-2024.R or .Rmd)

prop_detections <-  file.path('data/processed',
                         
                         c('OSM_proportional_detections_2021.csv',
                           'OSM_proportional_detections_2022.csv')) %>% 
  
  map(~.x %>%
        read_csv(.,
                 
                  # set the column types to read in correctly
                 col_types = cols(site = col_factor(),
                                  .default = col_number()))) %>% 
  
  # give names to each data frame in list
  purrr::set_names('prop_dets_2021',
                   'prop_dets_2022') # R doesn't like when they are just numbers, you can make it work but it's annoying to call the data frame later so I've called them prop_dets_year

# check variable structure
str(prop_detections)


```

### Merge data files 

Now we need to merge the two data files for analysis. We can do this with *dplyr*.

```{r merge prop dets}

# merge the proportional detections files so there are rows for both fiscal years
prop_dets_all <- dplyr::bind_rows(prop_detections$prop_dets_2021,
                                  prop_detections$prop_dets_2022)

print(prop_dets_all)
```

### Format data

This looks good except since there were no wolverines in the first fiscal year of monitoring (LU02 and LU03) those columns have NAs for both arrays, we want to replace those NAs with Zeros and move the wolverine column to the correct location

Let's do that now.

```{r format prop dets all}

prop_dets_all <- prop_dets_all %>% 
  
   # replace NAs introduced from joining data to zeros
  replace(is.na(.),
          0) %>% 
  
  # relocate wolverine column
  relocate(.,
           wolverine,
           .after = caribou)

# check data
head(prop_dets_all)

```
Looks good!


## Covariates

In the previous script, 2_ACME_landscape_covariate_exploration_script.Rmd we joined the two fiscal years of data and grouped the covariates for analysis and saved this data as a c.sv file, so we can read in this file now and we shouldn't have to do any further formatting at the moment

### Read data

We will check the data structure after reading in the file just to make sure everything looks good.
```{r read covs}

covariates_all <- read_csv('data/processed/OSM_covariates_grouped_2021_2022.csv',
                           
                           # set the column types to read in correctly
                           col_types = cols(array = col_factor(),
                                            camera = col_factor(),
                                            site = col_factor(),
                                            buff_dist = col_factor(),
                                            .default = col_number()))

str(covariates_all)

```
Everything looks good!

###Subset data by buffer

We need to subset the data so we have separate data frames for each buffer width to work with in the analysis **AND** to explore correlation between variables at each buffer width, as these may very with spatial scales

Let's use a for loop to subset the data
```{r subset data}
buffer_frames <- list()

for (i in unique(covariates_all$buff_dist)){
  
  print(i)
  
  # Subset data based on radius
  df <- covariates_all %>%
    filter(buff_dist == i)
  
  # list of dataframes
  buffer_frames <-c (buffer_frames, list(df))
}

# name list objects so we can extract names for plotting 

buffer_frames <- buffer_frames %>% 
  
  # absurdly long way to do this but for sake of time fuck it
  purrr::set_names('250 meter buffer',
                   '500 meter buffer',
                   '750 meter buffer',
                   '1000 meter buffer',
                   '1250 meter buffer',
                   '1500 meter buffer',
                   '1750 meter buffer',
                   '2000 meter buffer',
                   '2250 meter buffer',
                   '2500 meter buffer',
                   '2750 meter buffer',
                   '3000 meter buffer',
                   '3250 meter buffer',
                   '3500 meter buffer',
                   '3750 meter buffer',
                   '4000 meter buffer',
                   '4250 meter buffer',
                   '4500 meter buffer',
                   '4750 meter buffer',
                   '5000 meter buffer')
```

Now we have a list with data frames for each buffer width which we can work with later. 

### Add response metric

Now that we have the covariate data formatted we need to add the response metric (monthly proportional presence/absence) to the data frames

```{r response metric}

osm_final_df_2021_2022 <- buffer_frames %>% 
  
  purrr::map(
    ~.x %>% 
      
      left_join(prop_dets_all,
                by = 'site'))
```

### Finish with data formatting

Let's remove the objects we no longer need from the environment to keep our workspace clean

```{r rm data}
rm(covariates_all,
   prop_detections,
   df,
   i)
```

# Analysis

Now we are going to run a global model which includes all HFI and LC variables that at first glance (will do a more thorough check later) seem to have enough data to include as covariates for each buffer width, and then we will compare these models see which buffer width best fit the data  for each species. After that we will optimize models so they don't includes any variables that are highly correlated.

We don't need to do ALL the species since many don't have enough data.

> Refer to the 1_ACME_camera_script_9-2-2024.html or .Rmd the plot for proportional monthly detections should provide info on which species we have enough data for, can be found under Response metrics/3.Proportion monthly detections

A brief look at this fig indicates that we have enough for all the mammals in the prop_detections data frame **except**

* cougar    
* wolverine  
* caribou??? (may have enough, may not)


## Black bear 

> there is probably a way to shorten the following code to select particular species, I saw Andrew's for loop in the draft script he wrote but couldn't quite figure out how to adapt it to my purposes with the data formatted the way I have it, so I did this instead, maybe we can merge approaches later to clean this up if deemed necessary? But it certainly functions for now and is understandable... I think. 


### Global models

Let's start with bears and use purrr to create a global model for every buffer distance

Recall `purrr::map()` is magical for iterations and will apply all the functions within the `map()` function to each item of the list supplied before the the `map()` function.
```{r black bear global model}

# create models for black bears at each buffer size
black_bear_mods <- osm_final_df_2021_2022 %>%

  # use purrr map to run the same functions for all buffer sizes ((all objects in list))
  purrr::map(
    ~.x %>%

      # glmmTMB function let's us run the proportional binomial model using cbind to combine the present and absent columns for each species
     glmmTMB::glmmTMB(cbind(black_bear, absent_black_bear) ~
                        
                        # HFI
                        scale(harvest) +
                        scale(pipeline) +
                        scale(roads) +
                        scale(seismic_lines) +
                        scale(seismic_lines_3D) +
                        scale(trails) +
                        scale(transmission_lines) +
                        scale(veg_edges) +
                        scale(wells) +
                        scale(osm_industrial) +
                        
                        # VEG covariates in numerical order
                        scale(lc_grassland) +
                        scale(lc_coniferous) +
                        scale(lc_broadleaf) +
                        scale(lc_mixed) +
                        scale(lc_developed) +
                        scale(lc_shrub) +
                        
                        # Random effect of array
                        (1|array),
                   data = .,
                   family = 'binomial'))


```


#### Model selection

We will use the `model.sel()` function from the *MuMIn* package to compare the global models for each buffer width and see which buffer fits the black bear data best

```{r black bear mod selection}

model.sel(black_bear_mods)

```

Looks like the smallest buffer (250) fits the data best for black bears.

Let's look at this model closer

#### Model summary

```{r black bear 250 summary}

summary(black_bear_mods$`250 meter buffer`)
```
Nothing looks fishy in the model summary for now, we will look at this more closely once we have a true top model.

#### Code to remove a model

> At one point the 250 meter buffer was giving us issues so we had to remove it. After re-extracting the data and re-doing some data formatting this is no longer an issue but I've saved the code here in case it's needed in the future

```{r code to remove model, eval = FALSE}

# create models for black bears at each buffer size
black_bear_mods_no250 <- osm_final_df_2021_2022 %>%

# remove 250 meter buffer width
  purrr::discard_at('250 meter buffer') %>% 

  # use purrr map to fun the same functions for all buffer sizes ((all objects in list))
  purrr::map(
    ~.x %>%

      # glmmTMB function let's us run the proportional binomial model using cbind to combine the present and absent columns for each species
     glmmTMB::glmmTMB(cbind(black_bear, absent_black_bear) ~
                        
                        # HFI
                        scale(harvest) +
                        scale(pipeline) +
                        scale(roads) +
                        scale(seismic_lines) +
                        scale(seismic_lines_3D) +
                        scale(trails) +
                        scale(transmission_lines) +
                        scale(veg_edges) +
                        scale(wells) +
                        scale(osm_industrial) +
                        
                        # VEG covariates in numerical order
                        scale(lc_grassland) +
                        scale(lc_coniferous) +
                        scale(lc_broadleaf) +
                        scale(lc_mixed) +
                        scale(lc_developed) +
                        scale(lc_shrub) +
                        
                        # Random effect of array
                        (1|array),
                   data = .,
                   family = 'binomial'))
```


### Subset models

#### Autocorrelation 250m

Before we can develop model subsets we need to see what variables can be included in the same model at this buffer width.

Let's use the `chart.Correlation()` function in the *Performance Analytics* package to look at this.

```{r cor 250, warning=FALSE}

buffer_frames$`250 meter buffer` %>% 
  
  select_if(is.numeric) %>% 
  
   # use chart.correlation 
      chart.Correlation(.,
                        histogram = TRUE, 
                        method = "pearson")

mtext('250 meter buffer', side = 3, line = 3)
  
```
> You can click on this fig to zoom in!

List of correlated variables:   

* pipeline & transmission_lines 0.53    
* roads & veg_edges 0.71
* roads & lc_developed 0.57

#### Model list (Andrew can you review this)

> Jake/Andrew can you suggest some additional subset models if needed 

Let's create another global model without these correlated variables. I'm going to select transmission_lines over pipeline because the summary from earlier showed transmission lines had larger effect on black bear presence, and I'm going to choose to keep roads instead of veg edges and the developed landcover class because we are interested in the effect of roads more than these other two variables.

```{r black bear mods 250}

# global model w/ non-correlated variables
bear_global_250 <-  glmmTMB::glmmTMB(cbind(black_bear, absent_black_bear) ~
                        
                        # HFI
                        scale(harvest) +
                        scale(roads) +
                        scale(seismic_lines) +
                        scale(seismic_lines_3D) +
                        scale(trails) +
                        scale(transmission_lines) +
                        scale(wells) +
                        scale(osm_industrial) +
                        
                        # VEG covariates in numerical order
                        scale(lc_grassland) +
                        scale(lc_coniferous) +
                        scale(lc_broadleaf) +
                        scale(lc_mixed) +
                        scale(lc_shrub) +
                        
                        # Random effect of array
                        (1|array),
                   data = osm_final_df_2021_2022$`250 meter buffer`,
                   family = 'binomial')

# null model to compare
bear_null_250 <- glmmTMB::glmmTMB(cbind(black_bear, absent_black_bear) ~ 1 +
                        
                        # Random effect of array
                        (1|array),
                   data = osm_final_df_2021_2022$`250 meter buffer`,
                   family = 'binomial')

# second model is based on linear features providing easier movement through boreal forest
bear_linear_250 <- glmmTMB::glmmTMB(cbind(black_bear, absent_black_bear) ~
                        
                        # HFI
                        scale(roads) +
                        scale(seismic_lines) +
                        scale(seismic_lines_3D) +
                        scale(trails) +
                        scale(transmission_lines) +
                        
                        # Random effect of array
                        (1|array),
                   data = osm_final_df_2021_2022$`250 meter buffer`,
                   family = 'binomial')
```


#### Model selection

 Now let's look at a model selection table with our subset models.
 
```{r black bear mod selection 2}

model.sel(bear_global_250,
          bear_null_250,
          bear_linear_250)

```

Looks like the linear feature model is best, SO FAR

###  Top model

250 meter buffer - linear features

#### Summary

```{r bear summary}

summary(bear_linear_250)
```

#### Odds ratios

Let's extract the odds ratios for the top model so we can plot them for data vis later.


```{r bear odds ratios}
bear_model_odds <- bear_linear_250 %>% 

  # extract the coefficients and upper and lower CI
      confint() %>% 
 
      # format resulting object as a tibble data frame
      as_tibble() %>%
  
      
      # add a column where we can put the feature names
      rowid_to_column() %>% 
      
      # rename the columns for plotting
      rename('lower' = `2.5 %`,
             'upper' = `97.5 %`,
             'estimate' = Estimate,
             'feature' = rowid) %>% 
      
      # rename the entries to features, need to look at the order the features are in from the model summary and ensure it matches
      mutate(feature = as.factor(feature),
             feature = recode(feature,
                              '1' = 'intercept',
                              '2' = 'roads',
                              '3' = 'seismic_lines',
                              '4' = 'seismic_lines_3D',
                              '5' = 'trails',
                              '6' = 'transmission_lines',
                              '7' = 'intercept_array')) %>% 
  
  # remove intercepts
  filter(!grepl('intercept',
                feature))
```

#### Plot odds ratios

First let's get a silhouette for this graphy from phylopic

```{r bear phylopic}

black_bear_img <- get_phylopic(get_uuid(name = 'Ursus americanus'))
```


Now let's use ggplot to plot the odds ratios for each feature in the top model

```{r plot bear odds}

# provide data and mapping aesthetics
ggplot(bear_model_odds, aes(x = feature, 
                          y = estimate)) +
  
   geom_errorbar(aes(ymin = lower, 
                     ymax = upper),
                width = 0.4,
                linewidth = 0.5,
                position = position_dodge(width = 0.9)) +
  
   geom_hline(yintercept = 0, linetype = "dashed") +
  
  labs(y = 'Odds ratio') +
  
  scale_x_discrete(labels = c('Roads',
                              'Seismic Lines',
                              '3D Seismic Lines',
                              'Trails',
                              'Transmission Lines')) +
  
  add_phylopic(black_bear_img, 
               x = 5.3,
               y = 0.2,
               ysize = 0.05) +
  
  theme_classic() +
  
  theme(axis.title.x = element_blank(),
        axis.text.x = element_text(angle = 90,
                                   hjust = 1),
        axis.title = element_text(size = 16),
        axis.text = element_text(size = 14))
```

Let's repeat this process for each species that we have enough data for.

## Caribou

We may or may not have enough data for caribou but let's try it at least for this preliminary report

We can use the same code from black bears (above) to run global models for each buffer width **except remember we want to remove 250 meters**

And in the same chunk to save time let's also run the `model.sel()` function

### Global models
```{r caribou mods}

caribou_mods <- osm_final_df_2021_2022 %>%
  
  # use purrr map to make global models for all other buffer sizes
  purrr::map(
    ~.x %>%

     glmmTMB::glmmTMB(cbind(caribou, absent_caribou) ~
                        
                        # HFI
                        scale(harvest) +
                        scale(pipeline) +
                        scale(roads) +
                        scale(seismic_lines) +
                        scale(seismic_lines_3D) +
                        scale(trails) +
                        scale(transmission_lines) +
                        scale(veg_edges) +
                        scale(wells) +
                        scale(osm_industrial) +
                        
                        # VEG covariates in numerical order
                        scale(lc_grassland) +
                        scale(lc_coniferous) +
                        scale(lc_broadleaf) +
                        scale(lc_mixed) +
                        scale(lc_developed) +
                        scale(lc_shrub) +
                        
                        # Random effect of array
                        (1|array),
                   data = .,
                   family = 'binomial'))

# model selection
model.sel(caribou_mods)
```

We get a warning that there are some model convergence problems, I expect this is because we don't have enough data for caribou but I don't have time to dig into this now so we will investigate more closely for final analysis.

For now let's examine the top buffer width and see if the model seems reasonable.

>For caribou 3000m buffer is top model *for now*

#### Model summary 3000m

Let's take a closer look at the top model summary
```{r caribou 3000 summary}

summary(caribou_mods$`3000 meter buffer`)
```

There's nothing that catches my eye immediately as being sus about this particular model so it may not have been one with convergence issues. We will keep it in report for now

### Subset Models

Add later if deemed necessary.

### Top Model



## Coyote

### Global models
```{r coyote mods}

coyote_mods <- osm_final_df_2021_2022 %>%
  
  # use purrr map to make global models for all other buffer sizes
  purrr::map(
    ~.x %>%

     glmmTMB::glmmTMB(cbind(coyote, absent_coyote) ~
                        
                        # HFI
                        scale(harvest) +
                        scale(pipeline) +
                        scale(roads) +
                        scale(seismic_lines) +
                        scale(seismic_lines_3D) +
                        scale(trails) +
                        scale(transmission_lines) +
                        scale(veg_edges) +
                        scale(wells) +
                        scale(osm_industrial) +
                        
                        # VEG covariates in numerical order
                        scale(lc_grassland) +
                        scale(lc_coniferous) +
                        scale(lc_broadleaf) +
                        scale(lc_mixed) +
                        scale(lc_developed) +
                        scale(lc_shrub) +
                        
                        # Random effect of array
                        (1|array),
                   data = .,
                   family = 'binomial'))

# model selection
model.sel(coyote_mods)
```

> for coyote top model appears to be 2250 m

#### Model summary 2250m

Let's get the model summary for this model

```{r coyote 2250 summary}

summary(coyote_mods$`2250 meter buffer`)
```
Everything looks good here

### Subset models

Add later if deemed necessary.

### Top model



## Fisher

### Global models
```{r fisher mods}

fisher_mods <- osm_final_df_2021_2022 %>%
  
  # use purrr map to make global models for all other buffer sizes
  purrr::map(
    ~.x %>%

     glmmTMB::glmmTMB(cbind(fisher, absent_fisher) ~
                        
                         # HFI
                        scale(harvest) +
                        scale(pipeline) +
                        scale(roads) +
                        scale(seismic_lines) +
                        scale(seismic_lines_3D) +
                        scale(trails) +
                        scale(transmission_lines) +
                        scale(veg_edges) +
                        scale(wells) +
                        scale(osm_industrial) +
                        
                        # VEG covariates in numerical order
                        scale(lc_grassland) +
                        scale(lc_coniferous) +
                        scale(lc_broadleaf) +
                        scale(lc_mixed) +
                        scale(lc_developed) +
                        scale(lc_shrub) +
                        
                        # Random effect of array
                        (1|array),
                   data = .,
                   family = 'binomial'))
# model selection
model.sel(fisher_mods)
```

> For fisher top model is 1000 meter


#### Model summary 1000m

Let's print the summary for this model

```{r fisher 1000 summary}

summary(fisher_mods$`1000 meter buffer`)
```
Everything looks good

### Subset models

Add later if deemed necessary.

### Top model


## Grey wolf

### Global models

```{r wolf mods}

wolf_mods <- osm_final_df_2021_2022 %>%
  
  # use purrr map to make global models for all other buffer sizes
  purrr::map(
    ~.x %>%

     glmmTMB::glmmTMB(cbind(grey_wolf, absent_grey_wolf) ~
                        
                         # HFI
                        scale(harvest) +
                        scale(pipeline) +
                        scale(roads) +
                        scale(seismic_lines) +
                        scale(seismic_lines_3D) +
                        scale(trails) +
                        scale(transmission_lines) +
                        scale(veg_edges) +
                        scale(wells) +
                        scale(osm_industrial) +
                        
                        # VEG covariates in numerical order
                        scale(lc_grassland) +
                        scale(lc_coniferous) +
                        scale(lc_broadleaf) +
                        scale(lc_mixed) +
                        scale(lc_developed) +
                        scale(lc_shrub) +
                        
                        # Random effect of array
                        (1|array),
                   data = .,
                   family = 'binomial'))

# model selection
model.sel(wolf_mods)
```

> For grey wolf top model is 500 m buffer

#### Model summary 500m

Let's get the model summary for this model

```{r wolf 500 summary}

summary(wolf_mods$`500 meter buffer`)
```

interesting that seismic lines weren't significant but 3d seismic were and have a negative estimate

### Subset models

Add later if deemed necessary.

### Top model



## Lynx

###  Global models

```{r lynx mods}

lynx_mods <- osm_final_df_2021_2022 %>%
  
  # use purrr map to make global models for all other buffer sizes
  purrr::map(
    ~.x %>%

     glmmTMB::glmmTMB(cbind(lynx, absent_lynx) ~
                        
                       # HFI
                        scale(harvest) +
                        scale(pipeline) +
                        scale(roads) +
                        scale(seismic_lines) +
                        scale(seismic_lines_3D) +
                        scale(trails) +
                        scale(transmission_lines) +
                        scale(veg_edges) +
                        scale(wells) +
                        scale(osm_industrial) +
                        
                        # VEG covariates in numerical order
                        scale(lc_grassland) +
                        scale(lc_coniferous) +
                        scale(lc_broadleaf) +
                        scale(lc_mixed) +
                        scale(lc_developed) +
                        scale(lc_shrub) +
                        
                        # Random effect of array
                        (1|array),
                   data = .,
                   family = 'binomial'))

# model selection
model.sel(lynx_mods)
```

> For lynx the top model is the 1250 m buffer

#### Model summary 1250m

Let's get the model summary

```{r lynx 1250 summary}

summary(lynx_mods$`1250 meter buffer`)
```
Everything looks good so far

### Subset models

Add later if deemed necessary.

### Top model



## Moose

### Global model

```{r moose mods}

moose_mods <- osm_final_df_2021_2022 %>%
  
  # use purrr map to make global models for all other buffer sizes
  purrr::map(
    ~.x %>%

     glmmTMB::glmmTMB(cbind(moose, absent_moose) ~
                        
                        # HFI
                        scale(harvest) +
                        scale(pipeline) +
                        scale(roads) +
                        scale(seismic_lines) +
                        scale(seismic_lines_3D) +
                        scale(trails) +
                        scale(transmission_lines) +
                        scale(veg_edges) +
                        scale(wells) +
                        scale(osm_industrial) +
                        
                        # VEG covariates in numerical order
                        scale(lc_grassland) +
                        scale(lc_coniferous) +
                        scale(lc_broadleaf) +
                        scale(lc_mixed) +
                        scale(lc_developed) +
                        scale(lc_shrub) +
                        
                        # Random effect of array
                        (1|array),
                   data = .,
                   family = 'binomial'))

# model selection
model.sel(moose_mods)
```

> For moose the top model is the 250 m buffer

#### Model summary 250m

Let's get the model summary

```{r moose 250 summary}

summary(moose_mods$`250 meter buffer`)
```
Looks good for now

### Subset models

Add later if deemed necessary

### Top model



## Red fox

### Global models

```{r fox mods}
fox_mods <- osm_final_df_2021_2022 %>%
  
  # use purrr map to make global models for all other buffer sizes
  purrr::map(
    ~.x %>%

     glmmTMB::glmmTMB(cbind(red_fox, absent_red_fox) ~
                        
                         # HFI
                        scale(harvest) +
                        scale(pipeline) +
                        scale(roads) +
                        scale(seismic_lines) +
                        scale(seismic_lines_3D) +
                        scale(trails) +
                        scale(transmission_lines) +
                        scale(veg_edges) +
                        scale(wells) +
                        scale(osm_industrial) +
                        
                        # VEG covariates in numerical order
                        scale(lc_grassland) +
                        scale(lc_coniferous) +
                        scale(lc_broadleaf) +
                        scale(lc_mixed) +
                        scale(lc_developed) +
                        scale(lc_shrub) +
                        
                        # Random effect of array
                        (1|array),
                   data = .,
                   family = 'binomial'))


# model selection
model.sel(fox_mods)

```

> For red fox the top model is 4750 m buffer

#### Model summary 4750m

Let's get the model summary

```{r fox summary 4750}

summary(fox_mods$`4750 meter buffer`)
```

Looks good so far

### Subset Models

Add later if deemed necessary.

### Top model




## White-tailed deer

### Global models

```{r deer mods}

deer_mods <- osm_final_df_2021_2022 %>%
  
  # use purrr map to make global models for all other buffer sizes
  purrr::map(
    ~.x %>%

      # have to include the `` around the white-tailed_deer or R won't recognize it as a variable because of the -
     glmmTMB::glmmTMB(cbind(`white-tailed_deer`, `absent_white-tailed_deer`) ~
                        
                        # HFI
                        scale(harvest) +
                        scale(pipeline) +
                        scale(roads) +
                        scale(seismic_lines) +
                        scale(seismic_lines_3D) +
                        scale(trails) +
                        scale(transmission_lines) +
                        scale(veg_edges) +
                        scale(wells) +
                        scale(osm_industrial) +
                        
                        # VEG covariates in numerical order
                        scale(lc_grassland) +
                        scale(lc_coniferous) +
                        scale(lc_broadleaf) +
                        scale(lc_mixed) +
                        scale(lc_developed) +
                        scale(lc_shrub) +
                        
                        # Random effect of array
                        (1|array),
                   data = .,
                   family = 'binomial'))


# model selection
model.sel(deer_mods)
```

> For deer the top model was also the 1500 buffer

#### Model summary 1500m

Let's get the model summary

```{r deer 1500 summary}

summary(deer_mods$`1500 meter buffer`)
```
Looks okay for now

### Subset models

Add later if deemed necessary

### Top model

# Top buffers

For convenience here is a list of the top buffer widths for each species

* Black bear - 250m   
* Caribou - 3000m   
* Coyote - 2250m    
* Fisher - 1000m    
* Grey wolf - 500m    
* Lynx - 1250m    
* Moose - 250m    
* Red fox - 4750    
* White-tailed deer - 1500m   



# Plots for all species


## Buffer size

What I want to do here is create a figure that plots a point for each species at the buffer size that was in the top model.

### Data frame

Before we can do this I need to make a data frame that include the species, top buffer width, and any other info I may want in the plot.

```{r buffer data}

buffer_data <- tibble(
  
  #define number of rows
  .rows = 9,
  
  # create species column
  species = c('Black bear',
              'Caribou',
              'Coyote',
              'Fisher',
              'Grey wolf',
              'Lynx',
              'Moose',
              'Red fox',
              'White-tailed deer'),
  
  # create buffer column w/ buffer corresponding to the top model for each species
  buffer_width = c(250,
                   3000,
                   2250,
                   1000,
                   500,
                   1250,
                   250,
                   4750,
                   1500),
  
   # add phylopic uuid for each species for plotting 
  image = c(get_uuid(name = 'Ursus americanus'),
           get_uuid(name = 'Rangifer tarandus'),
           get_uuid(name = 'Canis latrans'),
           get_uuid(name = 'Pekania pennanti'),
           get_uuid(name = 'Canis lupus'),
           get_uuid(name = 'Lynx lynx'),
           get_uuid(name = 'Alces alces'),
           get_uuid(name = 'Vulpes vulpes'),
           get_uuid(name ='Odocoileus virginianus'))
  
)
```

### Plot

```{r plot buffers}

ggplot(buffer_data,
       aes( x = species,
            y = buffer_width)) +
  
  # add points as phylopic silhouettes
  geom_phylopic(aes(uuid = image),
                size = 500) +
  
  scale_y_continuous(breaks = seq(0, 5000, by = 250)) +
  
  coord_cartesian(ylim = c(0, 4900))
```
This looks alright but I don't love all the default phylopic images that are used. 


### Fix phylopics 

We can go to the [Phylopic website](https://www.phylopic.org/) and check out other options and then use the code below to search for the uuid from those options for the ones we want to replace

```{r search phylopic}

# Caribou could be bigger
get_uuid(name = 'Rangifer tarandus',
         n = 6) 
# I like the 5th one best

# Coyote doesn't need to have a food item
get_uuid(name = 'Canis latrans',
         n = 6) 
# I like the 6th one best

# Grey wolf shouldn't be the same as coyote
get_uuid(name = 'Canis lupus',
         n = 5) 
# I like 2 or 5

# Moose needs a body
get_uuid(name = 'Alces alces',
         n = 3) 
# 3 is best

# red fox is too big
get_uuid(name = 'Vulpes vulpes',
         n = 7) 
# 4 is best

# deer is weird
get_uuid(name = 'Odocoileus virginianus',
         n = 6) 
# 5 is best
```

Let's alter the code from above to change the phylopic images
```{r alter phylopic data}
buffer_data <- tibble(
  
  #define number of rows
  .rows = 9,
  
  # create species column
  species = c('Black bear',
              'Caribou',
              'Coyote',
              'Fisher',
              'Grey wolf',
              'Lynx',
              'Moose',
              'Red fox',
              'White-tailed deer'),
  
  # create buffer column w/ buffer corresponding to the top model for each species
  buffer_width = c(250,
                   3000,
                   2250,
                   1000,
                   500,
                   1250,
                   250,
                   4750,
                   1500),
  
   # add phylopic uuid for each species for plotting 
  image = c(get_uuid(name = 'Ursus americanus'),
            'e6e864fd-8e3d-435f-9db3-dc6869c589f1', # caribou 5
            'e6a2fa4b-85df-43b4-989c-34a65ba7eee3', # coyote 6
            get_uuid(name = 'Pekania pennanti'),
            '76c8fdec-d0af-47b9-b949-dc610419d832', # wolf 5
            get_uuid(name = 'Lynx lynx'),
            '74eab34a-498c-4614-aece-f02361874f79', # moose 3
            'd67d3bf6-3509-4ab6-819a-cd409985347e', # red fox 4
            '6038e80c-398d-47b2-9a69-2b9edf436f64') # white-tailed deer 6
  
)
```

### Plot again

Using the code from above with the fixed images let's plot it again

```{r plot buffers again}

buffer_plot <- ggplot(buffer_data,
                      aes( x = species,
                           y = buffer_width)) +
  
  # add points as phylopic silhouettes
  geom_phylopic(aes(uuid = image),
                size = 400) +
  
  # set axis limits and breaks
  scale_y_continuous(breaks = seq(0, 5000, by = 500)) +
  
  # wrap long species names
  scale_x_discrete(labels = function(x) str_wrap(x, width = 10)) +
  
  # set graph limits
  coord_cartesian(ylim = c(0,4900)) +
  
  # make nicer labels
  labs(y = 'Buffer width (meters)') +
  
  # set theme
  theme_bw() +
  theme(panel.grid.minor = element_blank(),
        axis.text = element_text(size = 14),
        axis.title = element_text(size = 16))

buffer_plot 
```

BEAUTIFUL!!! If I do say so myself

### Save plot

```{r save buffer plot}

ggsave('figures/OSM_species_buffers_2022.jpeg',
       buffer_plot,
       width = 18,
       height = 12,
       units = 'in',
       dpi = 600)
```


## Body size plot

Now I want to see if their are trends between body size and which bfuffer distance performed best. I'll first need to add a body size column to the data.

### Mutate data

To do this I'm going to google the avergae body size of each species and then add it as a column using mutate

> ** IMPORTANT - this is just for data visualization purposes!. Since we don't actually have data on body size of the individuals in our study I can't run any analysis on this but I can use it to visualize if there appears to be any trends worth investigating.

```{r}

# first add body size to buffer data
body_size_data <- buffer_data %>% 
  
  # use mutate to create new column
  mutate(body_size = case_when(species == 'Black bear' ~ 181,
                               species == 'Caribou' ~ 355,
                               species == 'Coyote' ~ 15,
                               species == 'Fisher' ~ 3.5,
                               species == 'Grey wolf' ~ 39,
                               species == 'Lynx' ~ 11,
                               species == 'Moose' ~ 555,
                               species == 'Red fox' ~ 5.2,
                               species == 'White-tailed deer' ~ 200),
         log_body_size = log(body_size))
```

### Plot

Now let's plot this as a scatterplot

```{r}

body_size_plot <- ggplot(body_size_data, aes(x = log_body_size,
                                             y = buffer_width)) +
  
  # add points as phylopic silhouettes
  geom_phylopic(aes(uuid = image),
                size = 400) +
  
  labs(x = 'Log body size (kg)',
       y = 'Buffer width (meters)') +
  
  # set theme
  theme_bw() +
  theme(panel.grid.minor = element_blank(),
        axis.text = element_text(size = 14),
        axis.title = element_text(size = 16))

body_size_plot
```

### Save plot

```{r}
ggsave('figures/OSM_body_size_buffers_2022.jpg',
       body_size_plot,
       width = 18,
       height = 12,
       units = 'in',
       dpi = 600)
```


## Odds ratio plots

What we need to do now is extract the coefficient estimates from each top model, as well as the 95% CI so we can plot them for easier visualization and understanding of the data


### Extract odds ratios

The `confint()` function will extract the coefficients and CI intervals from a model, so what we need to do is make a list of all the models, then use the `map()` function in *purrr* to apply the `confint()` function to all the models and get the coefficients. We want this to result in a tibble that has a column for the HFI feature (we aren't plotting the lc_class data for this report), the upper and lower CI, and the coefficient estimate.

In order to do this we have to do a bit of data wrangling, currently this isn't the most pleasing way to accomplish the desired outcome, but it works. 

```{r extract odds}

# This is also a dog shit way to do this but I need to get this done

# make a list of the top models for each species
top_models <- list(black_bear_mods$`250 meter buffer`,
                   caribou_mods$`3000 meter buffer`,
                   coyote_mods$`2250 meter buffer`,
                   fisher_mods$`1000 meter buffer`,
                   wolf_mods$`500 meter buffer`,
                   lynx_mods$`1250 meter buffer`,
                   moose_mods$`250 meter buffer`,
                   fox_mods$`4750 meter buffer`,
                   deer_mods$`1500 meter buffer`) %>%  
  
  # pipe into purrr to create coefficient table for all models
  purrr::map(
    ~.x %>% 
      
      # extract the coefficients and upper and lower CI
      confint() %>% 
      
      # format resulting object as a tibble data frame
      as_tibble() %>%
      
      # subset to just the HFI variables for these plots
      slice_head(n = 11) %>% 
      
      # remove first row which is the intercept
      slice_tail(n = 10) %>% 
      
      # add a column where we can put the feature names
      rowid_to_column() %>% 
      
      # rename the columns for plotting
      rename('lower' = `2.5 %`,
             'upper' = `97.5 %`,
             'estimate' = Estimate,
             'feature' = rowid) %>% 
      
      # rename the entries to features, need to look at the order the features are in from the model summary and ensure it matches
      mutate(feature = as.factor(feature),
             feature = recode(feature,
                              '1' = 'harvest',
                              '2' = 'pipeline',
                              '3' = 'roads',
                              '4' = 'seismic_lines',
                              '5' = 'seismic_lines_3D',
                              '6' = 'trails',
                              '7' = 'transmission_lines',
                              '8' = 'veg_edges',
                              '9' = 'wells',
                              '10' = 'osm_industrial'))) %>% 
  
  # set the names of each resulting tibble data frame to the species name
  purrr::set_names('Black bear',
                   'Caribou',
                   'Coyote',
                   'Fisher',
                   'Grey wolf',
                   'Lynx',
                   'Moose',
                   'Red fox',
                   'White-tailed deer')
```

### Merge data frames

Now we have a data frame with the odds ratios for each species, but if we want these on a plot together we need them all in one data frame. 

To merge data into one data frame we can use the `list_rbind()` function from the *purrr* package which will take each element of the list and stack them on top of one another just like rbind does with data frames, and if we use the names_to argument we can extract the names of the list elements and assign them to a column so we know which data comes from which species model (list element)

In this code I also add a new column called uuid which contains the image id (uuid) for a phylopic silhouette of each species that I may want to use for plotting

[Phylopic.or](https://www.phylopic.org/) is an open source online database of silhouettes various contributors have created for use. There is an R package that works with this data called *rphylopic*; we can use the `get_uuid()` function from this package to extract the data for a silhouette for each species we want, which is what I've done here.


```{r rbind odds}

# combine all list elements 
coeffs_df_all <- list_rbind(top_models,
                            names_to = 'species') %>% 
  
  # change species to a factor for plotting
  mutate(species = as.factor(species),
         
         # add phylopic uuid for each species for plotting 
         # the uuid is extracted using getuuid with the species name as name = ''
         uuid = case_when(species == 'Black bear' ~ get_uuid(name = 'Ursus americanus'),
                          species == 'Caribou' ~ get_uuid(name = 'Rangifer tarandus'),
                          species == 'Coyote' ~ get_uuid(name = 'Canis latrans'),
                          species == 'Fisher' ~ get_uuid(name = 'Pekania pennanti'),
                          species == 'Grey wolf' ~ get_uuid(name = 'Canis lupus'),
                          species == 'Lynx' ~ get_uuid(name = 'Lynx lynx'),
                          species == 'Moose' ~ get_uuid(name = 'Alces alces'),
                          species == 'Red fox' ~ get_uuid(name = 'Vulpes vulpes'),
                          species == 'White-taield deer' ~ get_uuid(name ='Odocoileus virginianus'))) 
  
```

### Plot odds all species

Now let's explore some different options to plot the coefficients

#### geom_phylopic

Let's try plotting all the species on one plot using `ggplot()`
```{r plot odds all}

# provide data and mapping aesthetics
ggplot(coeffs_df_all, aes(x = feature, 
                          y = estimate, 
                          group = uuid)) +
  
   geom_errorbar(aes(ymin = lower, 
                     ymax = upper, 
                     color = feature),
                width = 0.4,
                linewidth = 0.5,
                position = position_dodge(width = 0.9)) +
  
    # add points for each estimate for each covariate and use position = position_dodge to shift the points so all the species don't plot on top of one another
  geom_phylopic(aes(x = feature, 
                 y = estimate,
                 uuid = uuid),
             position = position_dodge(width = 0.9),
             size = 0.3)
  
  


```

This works but unfortunately is very messy with the images as the points since they don't all have the same centerline and are different sizes.

I try with the code below to select better silhouettes

```{r select silhouettes}

# combine all list elements 
coeffs_df_all <- list_rbind(top_models,
                            names_to = 'species') %>% 
  
  # change species to a factor for plotting
  mutate(species = as.factor(species),
         
         # add phylopic uuid for each species for plotting 
         # the uuid is extracted using getuuid with the species name as name = ''
         uuid = case_when(species == 'Black bear' ~ get_uuid(name = 'Ursus americanus'),
                           species == 'Caribou' ~ 'e6e864fd-8e3d-435f-9db3-dc6869c589f1', # caribou 5
                          species == 'Coyote' ~ 'e6a2fa4b-85df-43b4-989c-34a65ba7eee3', # coyote 6
                          species == 'Fisher' ~ '735066c6-2f3e-4f97-acb1-06f55ae075c9',
                          species == 'Grey wolf' ~ '76c8fdec-d0af-47b9-b949-dc610419d832', # wolf 5
                          species == 'Lynx' ~ '74eab34a-498c-4614-aece-f02361874f79', # moose 3
                          species == 'Moose' ~ '74eab34a-498c-4614-aece-f02361874f79',
                          species == 'Red fox' ~ 'd67d3bf6-3509-4ab6-819a-cd409985347e', # red fox 4
                          species == 'White-taield deer' ~ '6038e80c-398d-47b2-9a69-2b9edf436f64')) # white-tailed deer 6
```


Try plotting all again

```{r plot all odds 2}

ggplot(coeffs_df_all, aes(x = feature, 
                          y = estimate, 
                          group = uuid)) +
  
   geom_errorbar(aes(ymin = lower, 
                     ymax = upper, 
                     color = feature),
                width = 0.4,
                linewidth = 0.5,
                position = position_dodge(width = 1.2)) +
  
    # add points for each estimate for each covariate and use position = position_dodge to shift the points so all the species don't plot on top of one another
  geom_phylopic(aes(x = feature, 
                 y = estimate,
                 uuid = uuid),
             position = position_dodge(width = 1.2),
             size = 0.2)
  
  


```

Unfortunately they still don't center on the lines like they should so will try a different plot

#### Facet_wrap

```{r plot all odds facet_wrap}

ggplot(coeffs_df_all,
       aes(x = feature,
           y = estimate)) +
  
  # add points
  geom_point() +
  
  # add errorbar
  geom_errorbar(aes(ymin = lower, 
                     ymax = upper),
                width = 0.4,
                linewidth = 0.5) +
  
  facet_wrap(vars(species)) +
  
  # wrap long axis names
  scale_x_discrete(labels = function(x) str_wrap(x, width = 10)) +
  
  # adjust theme elements
  theme(axis.text.x = element_text(angle = 90,
                                   hjust = 1),
        axis.ticks.x = element_blank())
```

#### Plot_model

If all else fails can use [plot_model function](https://cran.r-project.org/web/packages/sjPlot/vignettes/plot_model_estimates.html)

##### Example with black bear model

```{r plot_model}

library(sjPlot)

plot_model(black_bear_mods$`250 meter buffer`,
           vline.color = 'black')
```

